---
title: Rust：闭包 closure
tags:
  - Rust
---

闭包（closure）是一种具有“捕获”外部变量能力的匿名函数。

- 可以像函数一样被调用
- 可以捕获当前环境中的变量

# 定义

```Rust
fn main() {
    let add = | a :i32, b:i32 | -> i32 { return a + b; } ;

    let x = add(1,2);
    println!("result is {}", x);
}
```

虽说是匿名函数，但是可以像变量赋值一样，能够将函数赋予一个变量 add

然后就可以像普通的函数一样进行调用

**闭包的其他写法**

```rust
let add = |a , b| {return a + b;};
let add = |a, b| a + b;
```

## 捕获当前环境中的变量

普通函数是不能直接访问函数外定义的变量的，会出现编译错误

```rust
fn main() {
    let x = 1_i32;

    fn inner_add() -> i32 {
        x + 1
    }

    let x2 = inner_add();
    println!("result is {}", x2);
}
```

> “error: can't capture dynamic environment in a fn item; use the || { ... } closure form instead [E0434]”

而闭包则可以进行访问

```rust
fn main() {
    let x = 1_i32;

    let inner_add = || x + 1;

    let x2 = inner_add();
    println!("result is {}", x2);
}
```

这一点也就是闭包和普通函数的最大区别。如果是在不需要捕获环境变量的场景，普通函数是可以和闭包呼唤使用的

有一点需要注意：Rust中函数声明和调用的位置并不重要，Rust中是不需要向前声明的。只要函数定义在当前范围内是可以观察到的，那就可以直接调用，不用管在源码内的相对位置如何。

# 外部变量的类型

Rust 是通过分析完毕变量在闭包中的使用方式，通过一系列的规则自动推到出来

1. 如果一个外部变量在闭包中，值通过借用指针&使用，那么这个变量就可以通过引用&的方式捕获
2. 如果一个外部变量在不包中，通过&mut指针使用过，那么这个变量就需要使用 &mut 的方式捕获
3. 如果一个外部变量在闭包中，通过所有权转移的方式使用过，那么这个变量就需要使用“by value”self的方式捕获

在保证能够编译通过的情况下，比那一期会自动选择一种对外部影响最小的类型存储。

**这里的匿名函数，并不是函数没有名字，而是访问外部变量的时候，变量的类型是匿名的**

# move 关键字

以上的变量捕获规则都是针对只作为局部变量的闭包。但是， 有时候闭包的生命周期可能会超过一个函数的范围。比如，将闭包存储到某个数据结构中，在当前函数返回之后继续使用。
这样一来，就可能出现更复杂的情况：在闭包被创建的时候，它通过引用的方式捕获了某些局部变量，而在闭包被调用的时候，它所指向的一些外部变量









  