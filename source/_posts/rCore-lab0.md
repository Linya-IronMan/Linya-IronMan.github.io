---
title: 'rCore: lab0'
tags:
  - rCore
  - Rust
  - 操作系统
---

# 相关资源

- [课程实践指导参考书](https://learningos.github.io/rCore-Tutorial-Book-v3/)
- [lab0-0 讲解视频](https://meeting.tencent.com/user-center/shared-record-info?id=5fcc9ef3-cb43-48f6-9d33-f75f640e8c38&from=3)
- [参考书：Operating Systems: Three Easy Pieces](https://pages.cs.wisc.edu/~remzi/OSTEP/)


# lab0-0讲解视频笔记

操作系统三座大山
- 虚拟化
- 并发
- 持久化

OS原理与设计思想
- 操作系统结构：如下图
- 中断及系统调用：区别于一般应用程序开发的线性思维
- 内存管理：操作系统对内存的申请、释放的封装
- 进程管理：如何有效地管理一堆同时运行的程序
- 处理机调度
- 同步互斥
- 文件系统
- IO子系统：对更多外设的支持

![](../rCore-lab0/2022-12-20-11-54-41.png)

我们的教学用操作系统是一个类Unix操作系统，单内核。
![](../rCore-lab0/2022-12-20-15-53-20.png)

![](../rCore-lab0/2022-12-20-15-55-37.png)
- 将CPU抽象成进程。将CPU的计算资源划分为不同的时段来共享。 进程实际上是对CPU的一种抽象
- 文件是对数据的一种抽象。磁盘是用于长期存储，内存在掉电之后数据就会丢失。而我们要使用磁盘中的数据，就需要先将数据读取到内存中；保存的时候也需要将数据从内存保存到磁盘中。而我们对磁盘以及内存的访问方式不同：磁盘通过一个个扇区进行访问；内存则是可以直接读取一个个字节。**为了在更高的层面上忽略这样的不同，就抽象出了“文件”的概念，用于统一数据在内存与磁盘上的读写。**
- 地址空间则是对内存的抽象。这个地址空间实际上是一种虚拟的、抽象的。实际内存可能只有8M但是地址空间可能会提供4G的空间的地址，远超过实际内存。这样做就是让程序在执行的时候不必担心内存不够用的情况。而实际使用的时候，我们只会将一些比较“活跃”的数据读取到内存中，通过这种方式来虚拟出N多的内存。

![](../rCore-lab0/2022-12-20-16-09-01.png)

应用程序以进程的方式运行，操作系统给这个进程提供一个完整的**虚拟环境**，让进程以为自己使用的是一个完整的计算机资源一样。
这是一种抽象，进程不需要去关心多个进程之间如何分配资源。那是整个操作系统负责管理的事情。
比如说，内存有8M的空间，虚拟出了4G的地址空间，分配了1G的空间给进程A使用，那么它使用的内存就不能超过1G。 CPU 则是按照时间进行资源的分配。

![](../rCore-lab0/2022-12-20-16-15-56.png)


![](../rCore-lab0/2022-12-20-18-07-05.png)

## 系统结构

### 单体分层结构

将单体操作系统划分为多层，每层建立在低层之上。最底层是硬件驱动，最高层是用户界面。
每一层仅使用更低一层的功能和服务。

问题：有些程序的开发会直接绕过这个层级划分，会直接访问内存并直接对其进行操作。这个时候就没有限制了。当软件越来越庞大的时候，开发也就越来越难了。

这来自产业界，用于开发功能较大，规模较大的系统

### 微内核架构

尽可能把内核功能移动到用户空间，用户模块之间的通信使用消息传递

- 好处：灵活/安全...
- 坏处：性能

内核只完成基本的硬件控制 —— 硬件抽象层。应用和应用之间通过LPC机制进行相互访问。
不直接访问是担心应用程序一会破坏应用程序二，不相信应用程序。

而文件系统、内存管理等都作为用户态的server存在。

这样的操作系统内核确实可以很小，几万行代码就可以。但实际中并没有得到大规模的应用。
因为所有的应用之间的消息传递机制虽然保证了安全，但是也降低了操作系统的性能。在完成一次客户对OS提出的服务请求时，需要利用消息实现**多次交互和进行用户/内核模式以及上下文的多次切换**。
与单核架构相比，性能可以差到3 - 5 倍，甚至是一个数量级。

在对一些安全性较高的场所，比如核电站、医疗设备等，有存在的价值。

![](../rCore-lab0/2022-12-22-15-54-34.png)





- LPC: 本地过程调用(Local Procedure Call)
- HAL: 硬件抽象层(Hardware Abstraction Layer)


### 外核结构

这个结构认为，传统的内核（TCP协议栈，文件系统等）应该和应用紧耦合，以库的形式与应用绑定。这样的绑定好像没什么安全感，但是这个应用要破坏就只能破坏自己，不能破坏别人。

而将最核心的那些和硬件相关的操作，放在了所谓的外核中。在这个外核中抽象出虚拟化出N个外设，使得TCP这些服务直接访问虚拟出的外设。

不同的应用可以有一个定制的内核，来满足特定的功能。

不过现在这样的操作系统还存在与论文上。

![](../rCore-lab0/2022-12-22-16-14-16.png)

### 虚拟机结构

外核结构实际上就是将低层的硬件资源尽量虚拟化，完成对上层应用的支持。这种思路实际上就是我们现在用的虚拟机。比如阿里腾讯的数据中心，云服务器。
可以使一台物理机变成了N个。

这实际上就是外核架构的扩展，不过不是为单一的应用设计一种内核，而是直接提供一个虚拟的计算机，虚拟的OS来对我们的应用进行支持。

![](../rCore-lab0/2022-12-22-16-15-01.png)

![](../rCore-lab0/2022-12-22-16-17-29.png)

### 总结

![](../rCore-lab0/2022-12-22-16-27-42.png)

操作系统实际上就是对硬件进行一层一层的抽象并对应用的执行提供支持。

进程通过地址空间管理存储空间，而进程就是应用程序的抽象。

硬件的抽象对程序的运行提供支持。


# 参考书练习题

- **什么是操作系统**
操作系统是管理计算机硬件资源、控制程序运行、改善人机界面和为应用软件提供支持的一种系统软件。在硬件和软件之间起到承上启下的作用。
"支持"并“控制”程序运行，比较公平地分配程序运行资源。如果一个软件对其他软件，或其他某一类软件的运行提供支持，都可以说是操作系统。
除了上面的比较泛化的解释，还有一种理解：运行在特权模式下的一种软件。

**操作系统是一个资源管理程序**
- 应用与硬件之间的中间层
- 管理各种软硬件资源
- 访问软硬件资源的服务
- 解决访问冲突，确保公平使用

**操作系统中的软件分类**
- Shell：命令行接口
- GUI：图形用户接口
- Kernel：操作系统的内部

![](../rCore-lab0/2022-12-20-15-42-30.png)

现在随着5G的发展，设备之间的互联更加高效、快速。出现了一种AloT操作系统。它应用于分布式的多设备集群之上，借助5G网络带来的高度通信能力进行信息交流。

![](../rCore-lab0/2022-12-20-17-57-31.png)

---

- **操作系统的特征**
- 并发
- 共享
- 虚拟
- 异步


# lab0-0 实验

实验环境：
- MacOS + Parrells Ubuntu 22
苹果电脑开Ubuntu22的虚拟机


