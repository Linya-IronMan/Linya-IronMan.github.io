---
title: 'rCore: 实践与实验简要分析'
date: 2022-12-23 09:55:27
tags:
  - rCore
  - OS
---

# 概览

实验按照逐步满足应用的需求设计的

1. **满足应用逐渐增加的需求**
- LibOS
- 批处理OS
- 多道程序与分时多任务OS
三种OS存在继承关系，逐步满足应用递增的需求。一层一层改进叠加所得

2. **为支持更加复杂的应用做出的抽象**
- 地址空间抽象
- 进程抽象
- 文件抽象

3. **应用所需要的多样性功能的支持**
- 可进程间通信的OS
- 可并发的OS
- 管理I/O设备的OS

## LibOS
缘故操作系统雏形，现代简单嵌入式操作系统
- 函数调用
- 编译器与操作系统的配合
- 硬件启动和软件启动的区别
- 编写/调试裸机程序
  还好有qemu模拟器，否则就完全没办法调试程序了。

## 批处理OS
支持程序执行切换

- 特权级/特权操作
- Risc-V 特权级/特权级操作
- 系统调用/异常
- 加载&执行&切换应用程序
- 特权级切换

需要确保APP和OS之间运行在不同的特性里来回自如切换。状态（寄存器）的保存与回复。

## 多道程序OS
支持多个程序驻留内存并依次执行

- 协作式调度
- 内存空间划分与管理

## 分时多任务OS

支持多个程序轮流执行

- 抢占式调度
- 中断处理
- 上下文切换

## 地址空间抽象的OS

支持程序间内存空间隔离

- 地址空间抽象
- 静态内存分配
- 动态内存分配
- 页式内存访问

**地址空间抽象：** 
为了安全，需要将不同的应用程序所使用的地址空间进行隔离。隔离之后，各个应用程序才能在有限的地址空间内舒适的运行。
每个程序需要知道自己所在的无力地址空间的位置，而这个位置，在编程的时候就需要指导，这就导致我们变成比较麻烦。
而使用虚地址空间之后，对每个程序来说，地址空间都可以从0开始。具体到哪个物理地址，有一个列表机制来完成映射的转换，这样写程序的时候就不用care，也更加安全。


页式内存访问：和物理硬件以及列表相关。

---

超越物理内存的虚拟存储

- 局部性原理
- 缺页异常
- 虚拟页式存储
- 置换算法

上面提到的列表只是完成了虚地址空间的映射，OS还有一个设计，让应用程序的到更大的方便，可以申请超过物理空间的一个虚拟存储。

实现思路就是将常用的放在内存中，不常用的就丢到硬盘上。访问不常用的数据，OS从硬盘读取数据的过程对于应用程序来说是无感知的。

而将硬盘上的数据导入到内存中来，涉及到一个置换算法。硬盘的数据读取速度要比内存慢上两个数量级或者更多，如何让这个导入的操作越少越好。

## 进程抽象的OS

支持动态创建程序执行

- 进程抽象
- 进程管理
- 调度机制

---

支持多处理器/多核计算

- 多处理器/多核架构
- 多处理器调度
- 实际OS调度

## 文件抽象的OS

处理数据的便捷长期存储

- 文件抽象
- 文件组织管理
- **文件系统设计与实现**

## 可进程间通信的OS

文件可能代表存储设备的一段数据，还可以调表其他东西。比如进程间需要传递的数据，以文件的方式来表示。

进程间可显式/隐式交互信息

- 信号 管道
- 消息队列 共享内存
- I/O 重定向

以文件描述符FD，来描述各种各样的资源，来完成信息的传递。

## 可并发的OS

更方便共享资源

- 线程：用户/内核线程
- 协程的机制
- 协程、线程、进程的关系

如何多个读进程，多个写进程对同一个数据进行合理的读写操作。

**一个进程包含多个线程，一个线程包含多个协程。**
粒度在越来越小，意味着对它的管理开销也在越来越小

问题：如果设计不当，出现死锁怎么办 dead lock。

## 管理I/O设备的OS

支持各种外设

- 设备抽象
- 设备执行模型
- 同步/异步 I/O
- I/Os 设备管理

I/O 设备如何交互，涉及到一些执行模型。

# 实验安排

实验一：操作系统的基本支持
- 计算机/OS启动
- 特权级切换
- 系统调用
- 应用程序/库/内核的关系
- 特权级相关异常、任务切换

实验二：地址空间 —— 地址空间抽象OS
- 地址空间
- 应用与内核之间在不同地址空间的数据交互/控制交互
- 内存/地址相关异常（如缺页异常）


实验三：进程管理与调度 —— 进程抽象OS
- 进程管理
- 调度算法


实验四：文件系统与进程间通信
- 文件系统实现
- 进程间通信机制

实验五：同步互斥
- 线程
- 同步互斥的机制
- 解决同步呼哧问题
- 死锁问题
- 优先级反转问题

![](../rCore-实践与实验简要分析/2022-12-23-11-19-18.png)


# Compiler 与 OS

实验中开发环境与实际的目标环境是不一样的，所以需要掌握一些椒炒编译的一套工具的使用。

之后可能需要将多个程序组合成一个大的程序。这个时候需要使用 linker （链接器）。
将多个机器码目标文件合成耽搁机器码执行文件。

OS工作：加载/执行/管理机器码执行文件

编译器/汇编器/链接器工作：源码 ---> 汇编码 ---> 机器码 ---> 执行程序

OS 则是由 Bootloader 加载并执行。还有一种东西来加载 Bootloader

ELF：Executable and Linkable Format 

## 操作系统执行环境

编译器工作三元组：

```rust
rustc --print target-list | grep riscv 

// 输出
riscv32gc-unknown-linux-gnu
riscv64imac-unknown-none-elf
```

linux-gnu 是连在一起的，linux 表示 kernel 内核；gnu代表的则是libc 库，后面的内容表示依赖的是什么库。这表示编译生成的是可以在linux上跑的，基于gnu-libc的应用程序。

除了 linux-gnu, 还有 linux-musl，这个musl也是一种库，C 语言的库。

none-elf 可以生成裸机程序，不需要有库。

**标准库：依赖操作系统**
Rust: std 标准库
C: glibc, musl libc 
**核心库: 与操作系统无关**
Rust: core库
C: Linux/BSD kernel libc

C语言由于历史原因，有很多不同的库，这造成了一些通用型的问题。比如针对Linux kernel 开发的一个内核模块，想放到BSD上面或者windows上面就特别困难，因为它们的低层都不一样。
而Rust因为比较新，只有 core 这一个库，就可以比较容易地去实现在不同的OS中。


## 裸机程序(Bare Metal program)

![](../rCore-实践与实验简要分析/2022-12-24-09-45-06.png)

这是一个能够通过Rust编译的程序。只是一个空的文件。

实际上在C语言的书写中会更加简单，因为C更加灵活，而Rust为了安全，做出了很多限制。
比如 panic 限制。要求程序崩溃之后必须panic处理。所以就要自己写一个panic处理方法。原本Rust自带的处理方法依赖于std标准库，无法用于elf操作系统的开发。
C语言就完全不用考虑这个问题。

## ELF 文件格式

![](../rCore-实践与实验简要分析/2022-12-24-09-54-38.png)

![](../rCore-实践与实验简要分析/2022-12-24-09-48-31.png)

[知乎：ELF文件格式](https://zhuanlan.zhihu.com/p/286088470#:~:text=ELF%E6%96%87%E4%BB%B6%E6%98%AF%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E3%80%81%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E3%80%81%E5%85%B1%E4%BA%AB%E5%BA%93%E5%92%8Ccore%E8%BD%AC%E5%AD%98%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E3%80%82.%20%E6%98%AFUNIX%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4%EF%BC%88USL%EF%BC%89%E4%BD%9C%E4%B8%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3%EF%BC%88Application,Binary%20Interface%EF%BC%8CABI%EF%BC%89%E8%80%8C%E5%BC%80%E5%8F%91%E5%92%8C%E5%8F%91%E5%B8%83%E7%9A%84%EF%BC%8C%E4%B9%9F%E6%98%AFLinux%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E3%80%82.)

如果这是一个OS，那么应该由boot loader把它加载到内存中去；如果是应用程序，应该由OS读取到内存中去。
但是有的时候，并不需要经过boot loader解析或者app解析。有的工具能够将ELF文件中的 text段、data段提取出来，放到内存中的约定的地址上，之后跳转到这个地址之上开始执行。这能够简化OS的加载过程以及OS加载应用的过程。

## App/OS 内存布局

应用和内存想要跑起来，需要对运行空间进行管理，一块是栈stack，一块是堆heap。
对于编译器而言更多只是涉及到了栈。因为要完成为函数以及局部变量参数保存合适的空间，生成正确的访问代码，这是对栈的操作。
这个栈上的空间是compiler确定空间地址，然后OS来生成的。ELF中的数据段、代码段的数据放入内存中后，由OS根据compiler的需求在指定的地方生成一块空间专门用作栈。
这里的compiler是泛化后的概念，指的是 compiler（高级语言到汇编） assember linker 合到一起的称呼

![](../rCore-实践与实验简要分析/2022-12-24-10-12-31.png)

- .text数据段：已初始化数据段 
- .rodata：只读的全局数据（常数或者是常量字符串）
- .data：可修改的全局数据
- .bss：未初始化数据段

堆(heap)向高地址增长
栈(stack)向低地址增长


应用程序是OS来帮忙生成栈空间，而在写OS的时候，就要在一开始的时候将栈空间生成好。



# 硬件启动与软件执行

![](../rCore-实践与实验简要分析/2022-12-24-10-18-07.png)

![](../rCore-实践与实验简要分析/2022-12-24-10-18-24.png)

- nographic 无图形界面
- bios 就是 bootloader ,machine mode
- device
  - loader: 在QEMU模拟器开机之前将一个宿主机上的文件在入道QEMU的无力内存的指定位置中
  - file: 设置待载入文件的路径
  - addr: 将文件载入到物理内存上的物理地址

一般来说，计算机加电之后的启动流程可以分为若干个阶段，每个阶段均由一层软件负责，每一层软甲男的功能是进行它应当承担的初始化工作，并在此之后跳转到下一层软件的入口地址，也就是将计算机的控制权移交给了下一层软件。

[计算机加电之后发生了什么](https://www.less-bug.com/posts/computer-power-up-after-what-happened/#:~:text=%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%A0%E7%94%B5%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%201%20%E5%BC%80%E6%9C%BA%E8%B7%B3%E7%BA%BF%20%E7%BB%99%E7%94%B5%E6%BA%90%E4%B8%8A%E7%94%B5%E4%B9%8B%E5%90%8E%EF%BC%8CATX%20%E7%94%B5%E6%BA%90%E5%B0%86%E4%BC%9A%E8%BF%9B%E5%85%A5%E5%BE%85%E6%9C%BA%E7%8A%B6%E6%80%81%E3%80%82%20%E7%94%B5%E6%BA%90%E4%B8%8E%E4%B8%BB%E6%9D%BF%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E8%80%97%E7%94%B5%E5%A4%96%E8%AE%BE%EF%BC%88%E5%A6%82%E7%A1%AC%E7%9B%98%E3%80%81%E5%85%89%E9%A9%B1%EF%BC%89%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BB%A5%E4%B8%BA%E5%85%B6%E4%BE%9B%E7%94%B5%E3%80%82%20...%202,%28baidu.com%29%20X86%E4%B8%8BLinux%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%20-%20kp_liu%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD%20%28cnblogs.com%29%20)


> 一开始应该是有一个固定的地方，从这个固定的地方读取到bios地址，跳转到那里开始执行 bios ，我们这里是 rustsbi-qemu。
> bios 完成基本的初始化之后，又会跳转到 OS 中开始执行。 去执行 os.bin

我们重点关注OS如何启动，并且OS启动之后如何去启动应用






















